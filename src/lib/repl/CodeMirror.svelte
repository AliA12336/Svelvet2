<script>
	import { onMount, createEventDispatcher } from 'svelte';
	import { writable } from 'svelte/store';
	import Message from './Message.svelte';
	import { addCodeToDB, getCodeFromDB, updateCodeInDB, deleteCodeFromDB } from '../../supabase-db.js';
	import { user_email, diagrams } from '$lib/stores/authStore.js';
	// import page from '@playwright/test';


	const dispatch = createEventDispatcher();

	export let readonly = false;
	export /**
	* @type {{ line: number; column: any; } | null}
	*/
	 let errorLoc = null;
	export let lineNumbers = true;
	export let tab = true;
	export /**
	* @type {any}
*/
	 let theme;

	/**
	* @type {number}
	*/
	let w;
	/**
	* @type {number}
	*/
	let h;
	let code = '';
	/**
	* @type {any}
	*/
	let mode;

	// We have to expose set and update methods, rather
	// than making this state-driven through props,
	// because it's difficult to update an editor
	// without resetting scroll otherwise
	export /**
	* @param {string} new_code
	* @param {any} new_mode
	*/
	 async function set(new_code, new_mode) {
		if (new_mode !== mode) {
			await createEditor(mode = new_mode);
		}

		code = new_code;
		updating_externally = true;
		if (editor) editor.setValue(code);
		updating_externally = false;
	}

	export /**
	* @param {string} new_code
	*/
	 function update(new_code) {
		code = new_code;

		if (editor) {
			const { left, top } = editor.getScrollInfo();
			editor.setValue(code = new_code);
			editor.scrollTo(left, top);
		}
	}

	export function resize() {
		editor.refresh();
	}

	export function focus() {
		editor.focus();
	}

	export function getHistory() {
		return editor.getHistory();
	}

	export /**
	* @param {any} history
	*/
	 function setHistory(history) {
		editor.setHistory(history);
	}

	export function clearHistory() {
		if (editor) editor.clearHistory();
	}

	export /**
	* @param {any} pos
	*/
	 function setCursor(pos) {
		if (editor) editor.setCursor(pos);
	}

	export const cursorIndex = writable(0);

	// @ts-ignore
	export function markText({ from, to }) {
		if (editor) editor.markText(editor.posFromIndex(from), editor.posFromIndex(to), { className: 'mark-text' });
	}

	export function unmarkText() {
		if (editor) editor.getAllMarks().forEach(m => m.clear());
	}


	export async function copyCodeEditor() {
		const code_to_copy = editor.getValue();

		const copyToClipboard = () => {
  		if (navigator && navigator.clipboard && navigator.clipboard.writeText){
    		return navigator.clipboard.writeText(code_to_copy);
			}
  		return Promise.reject('The Clipboard API is not available.');
		};

		copyToClipboard();
	}
	// pass in current project's id as argument
	export /**
	* @param {any} id
	* @param {any} diagramName
	*/
	 async function getCodeEditorValue(id, diagramName) {
		const codeToSave = editor.getValue();
		let found = false;

		if(diagramName && $diagrams.length < 6) { // && userCapacity < dbLimit
			// loop through the array of projects in store and check each object's id	
			for(const obj of $diagrams) {
				if(obj.id === id && obj.diagram_name === diagramName) {
					// update store before making db call
					console.log(obj);
					//obj.code.set(codeToSave);
					updateCodeInDB(id, codeToSave, $diagrams);
					// do a .then and set $diagrams = the returned project_store
					console.log("found value: " + found)
					alert('Diagram updated successfully!');
					document.getElementById('project-name').value = '';
					editor.setValue('');
					found = true;
				}
			}

			if(!found) {
				// diagrams.update();
				console.log("was found: " + found)
	  		addCodeToDB(codeToSave, $user_email, diagramName, $diagrams);
				alert('Diagram saved to database successfully!');
			}
		}
		else if($diagrams.length >= 6 && !found) {
			alert('You have reached the limit in terms of how many diagrams you can store. Please delete one to save a new diagram.');
		}
		else {
			alert('Please provide a name for your diagram before attempting to save.');
		}
		
	  // const canvas = document.getElementById('.s-UBc7zV9kI3Rx');
		// const dataURL = canvas?.getContext('2d')
		// console.log(dataURL);
	}
	
	export /**
* @param {string} code
*/
	 async function loadSavedCode(code) {
		editor.setValue(code);
	}

	export /**
* @param {any} id
*/
	 async function deleteCode(id) {
		deleteCodeFromDB(id, $diagrams);
		editor.setValue('');
		// @ts-ignore
		document.getElementById('project-name').value = '';
	}
	

	export /**
* @param {any} id
* @param {any} updated_code
*/
	 async function updateCode(id, updated_code) {
		updateCodeInDB(id, updated_code);
	}

	const modes = {
		js: {
			name: 'javascript',
			json: false
		},
		json: {
			name: 'javascript',
			json: true
		},
		svelte: {
			name: 'handlebars',
			base: 'text/html'
		},
		md: {
			name: 'markdown'
		}
	};

	const refs = {};
	/**
* @type {{ setValue: (arg0: string) => void; getScrollInfo: () => { left: any; top: any; }; scrollTo: (arg0: any, arg1: any) => void; refresh: () => void; focus: () => void; getHistory: () => any; setHistory: (arg0: any) => void; clearHistory: () => void; setCursor: (arg0: any) => void; markText: (arg0: { line: number; ch: any; }, arg1: { line: number; ch: any; }, arg2: { className: string; }) => void; posFromIndex: (arg0: any) => any; getAllMarks: () => any[]; getValue: () => any; removeLineClass: (arg0: any, arg1: string, arg2: string) => void; addLineClass: (arg0: any, arg1: string, arg2: string) => void; toTextArea: () => void; on: (arg0: string, arg1: { (instance: any): void; (instance: any): void; }) => void; }}
*/
	let editor;
	let updating_externally = false;
	/**
* @type {{ clear: () => void; }}
*/
	let marker;
	/**
* @type {number | null}
*/
	let error_line;
	let destroyed = false;
	/**
* @type {{ normalizeKeyMap: (arg0: { Enter: string; 'Ctrl-/': string; 'Cmd-/': string; 'Ctrl-Q': (cm: any) => void; 'Cmd-Q': (cm: any) => void; 
// allow escaping the CodeMirror with Esc Tab
'Esc Tab': boolean; }) => any; fromTextArea: (arg0: any, arg1: { lineNumbers: boolean; lineWrapping: boolean; indentWithTabs: boolean; indentUnit: number; tabSize: number; value: string; mode: any; readOnly: boolean; autoCloseBrackets: boolean; autoCloseTags: boolean; extraKeys: any; foldGutter: boolean; gutters: string[]; theme: any; }) => any; }}
*/
	let CodeMirror;

	$: if (editor && w && h) {
		editor.refresh();
	}

	$: {
		if (marker) marker.clear();

		if (errorLoc) {
			const line = errorLoc.line - 1;
			const ch = errorLoc.column;

			// @ts-ignore
			marker = editor.markText({ line, ch }, { line, ch: ch + 1 }, {
				className: 'error-loc'
			});

			error_line = line;
		} else {
			error_line = null;
		}
	}

	/**
* @type {null}
*/
	let previous_error_line;
	$: if (editor) {
		if (previous_error_line != null) {
			editor.removeLineClass(previous_error_line, 'wrap', 'error-line')
		}

		if (error_line && (error_line !== previous_error_line)) {
			editor.addLineClass(error_line, 'wrap', 'error-line');
			// @ts-ignore
			previous_error_line = error_line;
		}
	}

	onMount(() => {
		(async () => {
			if (!CodeMirror) {
				let mod = await import('./codemirror.js');
				CodeMirror = mod.default;
			}
			await createEditor(mode || 'svelte');
			if (editor) editor.setValue(code || '');
		})();

		return () => {
			destroyed = true;
			if (editor) editor.toTextArea();
		}
	});

	let first = true;

	/**
* @param {string | number} mode
*/
	async function createEditor(mode) {
		if (destroyed || !CodeMirror) return;

		if (editor) editor.toTextArea();

		const opts = {
			lineNumbers,
			lineWrapping: true,
			indentWithTabs: true,
			indentUnit: 2,
			tabSize: 2,
			value: '',
			// @ts-ignore
			mode: modes[mode] || {
				name: mode
			},
			readOnly: readonly,
			autoCloseBrackets: true,
			autoCloseTags: true,
			extraKeys: CodeMirror.normalizeKeyMap({
				'Enter': 'newlineAndIndentContinueMarkdownList',
				'Ctrl-/': 'toggleComment',
				'Cmd-/': 'toggleComment',
				'Ctrl-Q': function (cm) {
					cm.foldCode(cm.getCursor());
				},
				'Cmd-Q': function (cm) {
					cm.foldCode(cm.getCursor());
				},
				// allow escaping the CodeMirror with Esc Tab
				'Esc Tab': false
			}),
			foldGutter: true,
			gutters: ['CodeMirror-linenumbers', 'CodeMirror-foldgutter'],
			theme
		};

		if (!tab) {
			opts.extraKeys['Tab'] = tab;
			opts.extraKeys['Shift-Tab'] = tab;
		}

		// Creating a text editor is a lot of work, so we yield
		// the main thread for a moment. This helps reduce jank
		if (first) await sleep(50);

		if (destroyed) return;

		// @ts-ignore
		editor = CodeMirror.fromTextArea(refs.editor, opts);

		editor.on('change', instance => {
			if (!updating_externally) {
				const value = instance.getValue();
				dispatch('change', { value });
			}
		});

		editor.on('cursorActivity', instance => {
			cursorIndex.set(instance.indexFromPos(instance.getCursor()));
		});

		if (first) await sleep(50);
		editor.refresh();

		first = false;
	}

	/**
* @param {number | undefined} ms
*/
	function sleep(ms) {
		return new Promise(fulfil => setTimeout(fulfil, ms));
	}
</script>

<style>
	.codemirror-container {
		position: relative;
		width: 100%;
		height: 100%;
		border: none;
		line-height: 1.5;
		overflow: hidden;
	}

	.codemirror-container :global(.CodeMirror) {
		height: 100%;
		font: 400 var(--code-fs)/1.7 var(--font-mono);
	}

	.codemirror-container :global(.error-loc) {
		position: relative;
		border-bottom: 2px solid #da106e;
	}

	.codemirror-container :global(.error-line) {
		background-color: rgba(200, 0, 0, .05);
	}

	.codemirror-container :global(.mark-text) {
		background-color: var(--highlight);
	}

	textarea {
		visibility: hidden;
	}

	pre {
		position: absolute;
		width: 100%;
		height: 100%;
		top: 0;
		left: 0;
		border: none;
		padding: 4px 4px 4px 60px;
		resize: none;
		font-family: var(--font-mono);
		font-size: 13px;
		line-height: 1.7;
		user-select: none;
		pointer-events: none;
		color: #ccc;
		tab-size: 2;
		-moz-tab-size: 2;
	}
</style>

<div class='codemirror-container' bind:offsetWidth={w} bind:offsetHeight={h}>
	<textarea
		bind:this={refs.editor}
		readonly
		value={code}
	></textarea>

	{#if !CodeMirror}
		<pre style="position: absolute; left: 0; top: 0"
		>{code}</pre>

		<div style="position: absolute; width: 100%; bottom: 0">
			<Message kind='info'>loading editor...</Message>
		</div>
	{/if}
</div>

